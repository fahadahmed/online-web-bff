/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/v1/line/usage/me': {
    get: operations['getAllUsage'];
  };
  '/v1/line/usage/me/{lineNumber}': {
    get: operations['getUsage'];
  };
}

export interface definitions {
  UsageSummary: definitions['Response'] & {
    /** A list of the usage for each requested line, by line */
    line: definitions['Line'][];
  };
  /** The usage for a single line */
  Line: {
    /** The type of service the usage is for */
    serviceType: 'MOBILE' | 'BROADBAND' | 'WIRELESS_BROADBAND' | 'COPPER';
    /** Whether the service follows a prepaid billing model, or a postpaid model */
    balanceManagement: 'PREPAID' | 'POSTPAID';
    /** If the service type is a connection, this is the associated line number */
    connectionNumber: string;
    /** The name of the plan as it's marketed and shown to customers on the bill */
    planName: string;
    /** The offer id for the primary plan on the connection. */
    offerId: string;
    message?: definitions['UsageMessage'];
    /** The group and role within the group this line has. */
    group?: definitions['Group'];
    /** An array of the types of usage that are applicable to the connection */
    usage: definitions['Usage'][];
  };
  /** The message/text details, generated based on the status and type of the service */
  UsageMessage: {
    /** A message based on the status and type of the service */
    primary?: string;
    /** A message based on the status and type of the service.  This is broken in two so that the client can manage the presentation as required for the channel. */
    secondary?: string;
    /** Pertinent information about the connection */
    tertiary?: string;
    /** Status to indicate how to render the primary, secondary and tertiary properties */
    status?: 'WARNING' | 'IMPORTANT';
  };
  /** The group and role within the group this line has. */
  Group: {
    /** A reference to the group */
    id: string;
    /** In the case of shared group constructs the role of the line within the share construct is available */
    shareProfile?: string;
    /** The optional soft cap (will only be present for some sharers) */
    softcapValue?: number;
    /** The units of the soft cap */
    softcapUnit?: 'GB' | 'MB';
  };
  /** A particular type of usage that's applicable to the connection */
  Usage: {
    /** Indicates the order in which allowances are used. */
    priority?: number;
    /** The type of usage represented by this object */
    category: 'DATA' | 'TALK' | 'TEXT';
    /** The Siebel product instance id of the product this usage relates to. */
    productId?: string;
    /** The name of the product which the usage relates to. */
    productName?: string;
    /** The type of the product the usage relates to */
    productType?: string;
    /** The catalogue offer id of the product */
    offerId?: string;
    /** The type of usage */
    types: string[];
    /** whether this usage was roaming or local */
    roaming?: boolean;
    /** The name of the pack or extra this usage instance relates to */
    name?: string;
    /** The billing status for the plan or extra. */
    billingStatus?:
      | 'ACTIVE'
      | 'PENDING_FIRST_USE'
      | 'PENDING_PAYMENT'
      | 'PENDING_GR'
      | 'STOPPED'
      | 'GRACE';
    /** Uncapped means the usage is Unlimited */
    unCapped: boolean;
    /** The maximum for the type of usage; for this, a value of UNLIMITED represents an uncapped usage allowance */
    cap?: definitions['UsageValue'];
    /** the current amount used.  If there is an UNLIMITED cap, the value will be UNLIMITED. */
    used: definitions['SharerUsageValue'];
    /** the current amount remaining.  If there is an UNLIMITED cap, the value will be UNLIMITED */
    remaining?: definitions['UsageValue'];
    /** Contains the the data tiers */
    tiers?: definitions['Tier'][];
    /** Details related to when the pack or plan expires */
    expiry?: definitions['ExpiryDetails'][];
    /** The date this usage rolls over (renews) */
    nextRenewalDate?: string;
    /** If the product that contains this usage auto-renews, contains how it auto renews. */
    renewal?: 'AutoTopup' | 'GuaranteedRenewal';
  };
  SharerUsageValue: definitions['UsageValue'] & {
    /** The amount used by this sharer (optional; only returned for sharer lines). */
    bySharer?: number;
  };
  /** A representation of an amount of usage */
  UsageValue: {
    /** the amount */
    value: number;
    /** the units the value represents */
    unit: 'GB' | 'MB' | 'MIN' | 'TEXT';
  };
  Tier: {
    /** The current data tier the connection is on */
    cap: number;
  };
  ExpiryDetails: {
    /** The date when the plan or pack expires */
    date: string;
    /** The amount of usage which is going to expire */
    value?: number;
    /** the units the value represents */
    unit?: 'GB' | 'MB' | 'MIN' | 'TEXT';
  };
  Response: {
    /** List of Messages */
    messages: definitions['Message'][];
  };
  Message: {
    message: string;
    code: number;
  };
}

export interface operations {
  getAllUsage: {
    responses: {
      /** OK */
      200: {
        schema: definitions['UsageSummary'];
      };
      /** Unauthenticated */
      401: {
        schema: definitions['Response'];
      };
      /** INTERNAL_SERVER_ERROR */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  getUsage: {
    parameters: {
      path: {
        /** The line number to fetch the usage for */
        lineNumber: string;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['UsageSummary'];
      };
      /** Unauthenticated */
      401: {
        schema: definitions['Response'];
      };
      /** Not authorised to fetch usage about this line */
      403: {
        schema: definitions['Response'];
      };
      /** INTERNAL_SERVER_ERROR */
      500: {
        schema: definitions['Response'];
      };
    };
  };
}
