/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/v1/user/identity/availability/{email}': {
    get: operations['getIdentityAvailability'];
  };
  '/v1/user/identity/me': {
    get: operations['getIdentity'];
    patch: operations['updateIdentity'];
  };
  '/v2/user/identity/me': {
    patch: operations['updateIdentityV2'];
  };
  '/v1/user/identity': {
    get: operations['queryIdentities'];
    post: operations['createIdentity'];
  };
  '/v1/user/identity/me/verified': {
    /** If the value of verified in the body is false, and the myspark id is non-verified, sends a new token. */
    patch: operations['verifyWithToken'];
  };
  '/v1/user/identity/{email}/verified': {
    /** Only one of code, or token should be specified.  This sends the user a new code/token if the value of verified in the body is 'false' (and the user isn't already verified). */
    patch: operations['verifyWithCodeOrToken'];
  };
  '/v1/user/identity/{email}/password': {
    patch: operations['resetPassword'];
  };
  '/v1/user/identity/{email}/action/sparkForgottenPassword': {
    put: operations['initiateForgottenPassword'];
  };
  '/v1/user/identity/{maskedemail}/action/sparkForgottenUserId': {
    /** The name parameters should match the GET /v1/user/identity request that provided the obfuscated email address */
    put: operations['initiateForgottenUsername'];
  };
  '/v1/user/identity/biometrics': {
    post: operations['requestBiometricsIdentityBySMS'];
  };
  '/v1/user/identity/biometrics/status/{transactionId}': {
    get: operations['requestBiometricsProgressStatus'];
  };
}

export interface definitions {
  AvailabilityResponse: definitions['Response'] & {
    /** If the MySpark id is available for creation, true; false otherwise */
    available: boolean;
  };
  MinimalIdentityResponse: definitions['Response'] & {
    /** The MySpark/Skinny id corresponding to the provided token */
    uuid: string;
  };
  OptionalIdentityResponse: definitions['Response'] & {
    /** The MySpark/Skinny id corresponding to the provided token */
    uuid?: string;
  };
  VerificationRequest: {
    /** Whether this MySpark id has been verified */
    verified: boolean;
  };
  ChangePasswordRequest: {
    /** The proposed new password of the MySpark id. */
    password: definitions['Password'];
  };
  IdentityRequest: {
    /** The email address which is to be the public name of the MySpark id */
    email: string;
    /** The first name of the owner of the MySpark id. */
    firstName: string;
    /** The last name of the owner of the MySpark id. */
    lastName: string;
    /** The password of the MySpark id. */
    password: definitions['Password'];
    /** What type of verification process should be (initially?) used to verify this MySpark id */
    verificationType?: 'Token' | 'Code';
  };
  UpdateIdentityRequest: {
    /** The email address which is to be the new public name of the Spark id */
    email?: string;
    /** The new first name of the owner of the Spark id. */
    firstName?: string;
    /** The new last name of the owner of the Spark id. */
    lastName?: string;
    /** The new password of the Spark id. */
    password?: definitions['Password'];
    /** The new origin of the Spark id.  One can only set this to MySpark, and one must provide a password when the current origin is not MySpark. */
    origin?: 'MySpark';
    /** The new value of the mfa enabled flag.  If mfa is enabled, when the user logs in, they have to provide a one-time-password (sent to them via email). */
    mfaEnabled?: boolean;
  };
  /** A valid password is at least 8 characters long, has at least one capital letter, at least one number and at least one special character.  This still isn't ideal: see the example I've chosen. */
  Password: string;
  IdentityListResponse: definitions['Response'] & {
    /** A list of identities (restricted to a masked email address). */
    identities: definitions['ObfuscatedIdentity'][];
  };
  ObfuscatedIdentity: {
    /** The email address which is the public name of the MySpark id; note that this is masked with '*' */
    email: string;
    /** A unique identifier (in the context of the response) for this email */
    rowId: number;
  };
  SocialProviderResponse: definitions['Response'] & {
    /** The social provider that should actually be used to manage this identity. */
    socialProvider: 'Google' | 'Facebook';
  };
  BiometricsRequest: {
    /** Online order number, required to match order with biometrics results. */
    onlineOrderNumber: string;
    /** The phone number that the SMS should be sent to, only New Zealand numbers are permitted. */
    phoneNumber: string;
    /** Customer full name */
    name: string;
  };
  BiometricsStatusResponse: definitions['Response'] & {
    biometrics: definitions['BiometricsStatus'];
  };
  BiometricsResponse: definitions['Response'] & {
    biometrics: definitions['Biometrics'];
  };
  Biometrics: {
    /** Transaction ID (OnlineOrderNumber) */
    id: string;
    /** Status as per response from OCRLabs */
    status: 'success' | 'error';
  };
  BiometricsStatus: {
    /** Online Order Number that passed to OCRLabs */
    transactionId: string;
    /** Transaction status */
    status:
      | 'PENDING'
      | 'COMPLETED_PASS'
      | 'COMPLETED_FLAGGED'
      | 'CANCELLED'
      | 'INPROGRESS';
  };
  Response: {
    /** List of Messages */
    messages: definitions['Message'][];
  };
  Message: {
    message: string;
    code: number;
  };
}

export interface parameters {
  /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
  realmParam: 'SPARK_ID' | 'MYSB' | 'SKINNY';
}

export interface operations {
  getIdentityAvailability: {
    parameters: {
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        realm?: parameters['realmParam'];
      };
      path: {
        /** The email address to be used for a MySpark id */
        email: string;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['AvailabilityResponse'];
      };
      /** The provided email address does not look like one. */
      400: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  getIdentity: {
    responses: {
      /** OK */
      200: {
        schema: definitions['MinimalIdentityResponse'];
      };
      /** The provided token is invalid */
      401: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  updateIdentity: {
    parameters: {
      query: {
        /** The token used to verify the Spark id.  Only one of code or token should be specified, and only if email is present in the body. */
        token?: string;
        /** The code used to verify the MySpark id.  Only one of code or token should be specified, and only if email is present in the body. */
        code?: string;
        /** Should only be used if email is present in the body; in that case, this indicates which of a code or token should be used to verify the Spark id (and code and token shouldn't be present). */
        verifyBy?: 'Code' | 'Token';
      };
      body: {
        updateIdentityRequest?: definitions['UpdateIdentityRequest'];
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['Response'];
      };
      /** The provided UpdateIdentityRequest does not appear to be valid. */
      400: {
        schema: definitions['Response'];
      };
      /** No, invalid, or expired code and/or token was provided (if no code or token was provided, one will have been sent). */
      403: {
        schema: definitions['Response'];
      };
      /** Too many recent attempts to change the email address of this Spark Id. */
      429: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  updateIdentityV2: {
    parameters: {
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        realm?: parameters['realmParam'];
      };
      query: {
        /** The token used to verify the Spark id.  Only one of code or token should be specified, and only if email is present in the body. */
        token?: string;
        /** The code used to verify the MySpark id.  Only one of code or token should be specified, and only if email is present in the body. */
        code?: string;
        /** Should only be used if email is present in the body; in that case, this indicates which of a code or token should be used to verify the Spark id (and code and token shouldn't be present). */
        verifyBy?: 'Code' | 'Token';
      };
      body: {
        updateIdentityRequest?: definitions['UpdateIdentityRequest'];
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['Response'];
      };
      /** The provided UpdateIdentityRequest does not appear to be valid. */
      400: {
        schema: definitions['Response'];
      };
      /** No, invalid, or expired code and/or token was provided (if no code or token was provided, one will have been sent). */
      403: {
        schema: definitions['Response'];
      };
      /** Too many recent attempts to change the email address of this Spark Id. */
      429: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  queryIdentities: {
    parameters: {
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        realm?: parameters['realmParam'];
      };
      query: {
        /** The first name of the myspark identities that should be returned.  If this is provided, lastName must also be. */
        firstName?: string;
        /** The last name of the myspark identities that should be returned.  If this is provided, firstName must also be. */
        lastName?: string;
        /** The business name of the myspark identities that should be returned.  If this is provided, firstName and lastName must not be. */
        businessName?: string;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['IdentityListResponse'];
      };
      /** The provided parameters do not appear to be valid. */
      400: {
        schema: definitions['Response'];
      };
      /** No such identities were found. */
      404: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  createIdentity: {
    parameters: {
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        realm?: parameters['realmParam'];
      };
      body: {
        identityRequest?: definitions['IdentityRequest'];
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['MinimalIdentityResponse'];
      };
      /** The provided IdentityRequest does not appear to be valid. */
      400: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  /** If the value of verified in the body is false, and the myspark id is non-verified, sends a new token. */
  verifyWithToken: {
    parameters: {
      query: {
        /** The token used to verify the MySpark id. */
        token: string;
        /** If the value of verified in the body is false, this is used to determine how the resend of the verification should proceed; note that one can convert a token into a code & vice-versa */
        verifyBy?: 'Code' | 'Token';
      };
      body: {
        verificationRequest?: definitions['VerificationRequest'];
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['MinimalIdentityResponse'];
      };
      /** One of many possible validation failures. */
      400: {
        schema: definitions['Response'];
      };
      /** The provided token is invalid or expired.  If the token is expired, the uuid corresponding to it will be returned. */
      403: {
        schema: definitions['OptionalIdentityResponse'];
      };
      /** The requested identity doesn't exist. */
      404: {
        schema: definitions['Response'];
      };
      /** There have been too many recent requests to validate this identity. */
      429: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  /** Only one of code, or token should be specified.  This sends the user a new code/token if the value of verified in the body is 'false' (and the user isn't already verified). */
  verifyWithCodeOrToken: {
    parameters: {
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        realm?: parameters['realmParam'];
      };
      query: {
        /** The code used to verify the MySpark id. */
        code?: string;
        /** The token used to verify the MySpark id. */
        token?: string;
        /** If the value of verified in the body is false, this is used to determine how the resend of the verification should proceed; note that one can convert a token into a code & vice-versa, or not even have a code or token provided in this request. */
        verifyBy?: 'Code' | 'Token';
      };
      path: {
        /** The email address of the Spark id to verify */
        email: string;
      };
      body: {
        verificationRequest?: definitions['VerificationRequest'];
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['MinimalIdentityResponse'];
      };
      /** One of many possible validation failures. */
      400: {
        schema: definitions['Response'];
      };
      /** The provided token is invalid or expired.  If the token is expired, the uuid corresponding to it will be returned. */
      403: {
        schema: definitions['OptionalIdentityResponse'];
      };
      /** The requested identity doesn't exist. */
      404: {
        schema: definitions['Response'];
      };
      /** There have been too many recent requests to validate this identity. */
      429: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  resetPassword: {
    parameters: {
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        realm?: parameters['realmParam'];
      };
      path: {
        /** The email address which is the public name of the MySpark id to reset the password of. */
        email: string;
      };
      query: {
        /** The token used to grant permission to reset password. */
        token: string;
      };
      body: {
        changePasswordRequest?: definitions['ChangePasswordRequest'];
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['Response'];
      };
      /** One of many possible validation failures. */
      400: {
        schema: definitions['Response'];
      };
      /** The provided token is invalid or expired. */
      403: {
        schema: definitions['Response'];
      };
      /** There have been too many recent requests to reset this identity's password. */
      429: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  initiateForgottenPassword: {
    parameters: {
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        realm?: parameters['realmParam'];
      };
      path: {
        /** The email address which is the public name of the MySpark id to initiate forgotten password on. */
        email: string;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['Response'];
      };
      /** One of many possible validation failures. */
      400: {
        schema: definitions['Response'];
      };
      /** The spark id selected is a social one, and can't be used with forgotten password. */
      403: {
        schema: definitions['SocialProviderResponse'];
      };
      /** No such identity was found. */
      404: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  /** The name parameters should match the GET /v1/user/identity request that provided the obfuscated email address */
  initiateForgottenUsername: {
    parameters: {
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        realm?: parameters['realmParam'];
      };
      query: {
        /** The first name of the myspark identities that should be returned.  If this is provided, lastName must also be. */
        firstName?: string;
        /** The last name of the myspark identities that should be returned.  If this is provided, firstName must also be. */
        lastName?: string;
        /** The business name of the myspark identities that should be returned.  If this is provided, firstName and lastName must not be. */
        businessName?: string;
        /** The rowId that corresponds to the maskedemail */
        rowId: number;
      };
      path: {
        /** The obfuscated MySpark id to send a forgotten username mail to. */
        maskedemail: string;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['Response'];
      };
      /** One of many possible validation failures. */
      400: {
        schema: definitions['Response'];
      };
      /** The spark id selected is a social one, and can't be used with forgotten username (or forgotten password). */
      403: {
        schema: definitions['SocialProviderResponse'];
      };
      /** No such identities were found (either via the name look up, or the obfuscated name isn't one returned by the name lookup). */
      404: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  requestBiometricsIdentityBySMS: {
    parameters: {
      body: {
        biometricsRequest: definitions['BiometricsRequest'];
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['BiometricsResponse'];
      };
      /** One of many possible validation failures. */
      400: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  requestBiometricsProgressStatus: {
    parameters: {
      path: {
        /** This is Online Order Number and is used as transactionId to retrieve the IDV transaction results */
        transactionId: string;
      };
    };
    responses: {
      /** OK */
      200: {
        schema: definitions['BiometricsStatusResponse'];
      };
      /** One of many possible validation failures. */
      400: {
        schema: definitions['Response'];
      };
      /** The server failed to process the request properly. */
      500: {
        schema: definitions['Response'];
      };
    };
  };
}
