/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/v1/user/oidc/accessToken': {
    post: operations['accessTokenUsingPOST'];
  };
  '/v1/user/oidc/social': {
    post: operations['oidcSocialLogin'];
  };
  '/v1/user/oidc/userInfo': {
    get: operations['userInfoUsingGET'];
  };
  '/v1/user/oidc/revoke': {
    post: operations['revokeToken'];
  };
  '/v1/user/oidc/logout': {
    get: operations['logOut'];
  };
  '/v1/user/oidc/authorize': {
    post: operations['authorize'];
  };
  '/v1/user/oidc/authenticate': {
    post: operations['authenticate'];
  };
  '/v1/user/oidc/authenticate/mfa/verification': {
    post: operations['supplyFactor'];
  };
  '/v1/user/oidc/authenticate/mfa/renew': {
    get: operations['resendFactor'];
  };
}

export interface definitions {
  AccessTokenResponse: definitions['Response'] & {
    /** Valid access token returned from OpenAm */
    access_token: string;
    /** In how many seconds the access token will expire */
    expires_in: number;
    /** Json web token representing identity information about the user */
    id_token: string;
    /** The token which can be used to regenerate access token */
    refresh_token: string;
    /** Way to restrict access to specified areas */
    scope: string;
    /** The type of the access token, which defines how it is constructed */
    token_type: 'Bearer' | 'MAC';
  };
  UserInfo: definitions['Response'] & {
    /** Similar to sscid, which is a SSC number */
    sub: string;
    /** User's first name */
    firstName?: string;
    /** User's last name */
    lastName?: string;
    /** The Unix Epoch Date when the user logged in last time */
    lastLogin?: string;
    /** User account verification status */
    isVerified: boolean;
    /** Company or business name for business users */
    company?: string;
    /** Origin of registration */
    origin: 'MySpark' | 'Facebook' | 'Google' | 'Apple' | 'MYSB';
    /** The type of the App user used to sign in */
    loginOption: string;
    /** Timestamp when the user info was updated */
    updated_at?: string;
    /** Spark SSC ID */
    sparkID: string;
    /** User's email address */
    email: string;
    /** Social facebook ID linked to sparkID */
    socialFBId?: string;
    /** Social Google ID linked to sparkID */
    socialGGId?: string;
    /** Social Apple ID linked to sparkID */
    socialAppleId?: string;
    /** The type of mfa this user has requested.  null or blank is 'none'; the only other currently-implemented value is 'email'. */
    mfaOption?: string;
    act?: definitions['Act'];
  };
  Act: {
    /** Represents t-number when its an impersonation. */
    sub?: string;
  };
  OauthErrorResponse: {
    /** Error code elaborated in RFC6749 section 5.2 */
    error:
      | 'invalid_request'
      | 'invalid_client'
      | 'invalid_grant'
      | 'invalid_token'
      | 'unauthorized_client'
      | 'unsupported_grant_type'
      | 'error_description'
      | 'error_uri';
    /** List of Messages */
    messages: definitions['Message'][];
  };
  AuthenticationResponse: definitions['Response'] & {
    /** Used by /authorize to complete the authentication.  Will only be present if either mfa isn't required, or has successfully completed. */
    sessionId?: string;
    /** Present exactly when sessionId is not present (i.e. mfa is required); MFA type */
    stage?: string;
    /** Present exactly when sessionId is not present (i.e. mfa is required); nonce for MFA */
    nonce?: string;
    /** The value of a cookie used for session stickiness between this service & AM */
    amlb?: string;
  };
  MfaRenewResponse: definitions['Response'] & {
    /** MFA type */
    stage: string;
    /** nonce for MFA */
    nonce: string;
  };
  AuthorisationResponse: definitions['Response'] & {
    /** The returned authorisation code */
    code: string;
    /** The state provided by the client in the request. */
    state: string;
    /** The requesting client id */
    client_id: string;
  };
  Response: {
    /** List of Messages */
    messages: definitions['Message'][];
  };
  Message: {
    message: string;
    code: number;
  };
}

export interface parameters {
  /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
  Realm: 'SPARK_ID' | 'MYSB';
}

export interface operations {
  accessTokenUsingPOST: {
    parameters: {
      formData: {
        /** The grant type according to RFC 6749 */
        grant_type: 'authorization_code' | 'password' | 'refresh_token';
        /** Authorization code according to RFC 6749 */
        auth_code?: string;
        /** Resource owner username according to RFC 6749 */
        username?: string;
        /** Resource owner password according to RFC 6749 */
        password?: string;
        /** Refresh token according to RFC 6749 */
        refresh_token?: string;
      };
      header: {
        /** Base64 encoded client_id and client_secret string according to RFC 6749 */
        Authorization: string;
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        Realm?: parameters['Realm'];
      };
    };
    responses: {
      /** Correct access token and refresh token returned */
      200: {
        schema: definitions['AccessTokenResponse'];
      };
      /** Bad Request, internal error code 4200 */
      400: {
        schema: definitions['OauthErrorResponse'];
      };
      /** Unauthenticated, internal error code 4100 */
      401: {
        schema: definitions['OauthErrorResponse'];
      };
      /** Internal Server Error, internal error code 5200 */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  oidcSocialLogin: {
    parameters: {
      formData: {
        /** Json Web Token (JWT, alg: HS256) generated by Facebook, Google or Apple */
        socialToken: string;
        /** social token provider */
        socialProvider: 'FACEBOOK' | 'GOOGLE' | 'APPLE';
        /** The client name registered in OpenAm */
        clientName: 'SparkApp' | 'SparkWeb';
        /** The first name of the user which is required by Apple Inc. only */
        firstNameApple?: string;
        /** The last name of the user which is required by Apple Inc. only */
        lastNameApple?: string;
      };
      header: {
        /** Base64 encoded client_id and client_secret string according to RFC 6749 */
        Authorization: string;
      };
    };
    responses: {
      /** Correct access token and refresh token returned */
      200: {
        schema: definitions['AccessTokenResponse'];
      };
      /** Bad Request, internal error code 4200 */
      400: {
        schema: definitions['OauthErrorResponse'];
      };
      /** Unauthenticated, internal error code 4100 */
      401: {
        schema: definitions['OauthErrorResponse'];
      };
      /** Internal Server Error, internal error code 5200 */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  userInfoUsingGET: {
    parameters: {
      header: {
        /** Access token in the Authorization header of the request sent to OpenAM */
        Authorization: string;
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        Realm?: parameters['Realm'];
      };
    };
    responses: {
      /** Successfully fetched user information */
      200: {
        schema: definitions['UserInfo'];
      };
      /** Bad Request, internal error code 4200 */
      400: {
        schema: definitions['OauthErrorResponse'];
      };
      /** Unauthenticated, internal error code 4100 */
      401: {
        schema: definitions['OauthErrorResponse'];
      };
      /** Internal Server Error, internal error code 5200 */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  revokeToken: {
    parameters: {
      formData: {
        /** access token or refresh_token to be revoked */
        token: string;
      };
      header: {
        /** Base64 encoded client_id and client_secret string according to RFC 6749 */
        Authorization: string;
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        Realm?: parameters['Realm'];
      };
    };
    responses: {
      /** Returns a success message if the token has been successfully revoked */
      200: {
        schema: definitions['Response'];
      };
      /** Bad Request */
      400: {
        schema: definitions['Response'];
      };
      /** Unauthenticated */
      401: {
        schema: definitions['OauthErrorResponse'];
      };
      /** Internal Server Error */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  logOut: {
    parameters: {
      query: {
        /** Id Token in JWT, which is issued by OpenAM */
        idToken: string;
      };
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        Realm?: parameters['Realm'];
      };
    };
    responses: {
      /** Successfully logs out the user */
      200: {
        schema: definitions['Response'];
      };
      /** Bad Request */
      400: {
        schema: definitions['Response'];
      };
      /** Internal Server Error */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  authorize: {
    parameters: {
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        Realm?: parameters['Realm'];
      };
      formData: {
        /** client_id - used to identify the client device type to OpenAM */
        client_id: string;
        /** the 'credential' that the authorize should return.  The only supported value currently is 'code' */
        response_type: string;
        /** A sessionId, returned by /v1/user/oidc/authenticate. */
        sessionId: string;
        /** Callback location where the authorization code or tokens should be sent */
        redirect_uri: string;
        /** The only currently supported value for this is 'none'.  Causes the server to return a 401 response when the sessionId is invalid */
        prompt: string;
        /** openid is required for authentication requests. */
        scope: string;
        /** A client-supplied value to be returned in the token & response - for csrf mitigation. */
        state: string;
        /** A client-supplied value to be returned in the id_token - for replay attack mitigation. */
        nonce: string;
      };
    };
    responses: {
      /** A successful authorisation. */
      200: {
        schema: definitions['AuthorisationResponse'];
      };
      /** Bad Request: one or more parameters is missing or invalid */
      400: {
        schema: definitions['Response'];
      };
      /** The session id was invalid */
      401: {
        schema: definitions['Response'];
      };
      /** Internal Server Error */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  authenticate: {
    parameters: {
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        Realm?: parameters['Realm'];
      };
      formData: {
        /** username of the customer credentials */
        username: string;
        /** password of the customer credentials */
        password: string;
      };
    };
    responses: {
      /** For either of MFA required or not. */
      200: {
        schema: definitions['AuthenticationResponse'];
      };
      /** Bad Request */
      400: {
        schema: definitions['Response'];
      };
      /** Bad credentials presented, most likely */
      401: {
        schema: definitions['Response'];
      };
      /** I don't know when this will be returned */
      403: {
        schema: definitions['Response'];
      };
      /** Internal Server Error */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  supplyFactor: {
    parameters: {
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        Realm?: parameters['Realm'];
      };
      formData: {
        /** this is the OTP */
        mfaToken: string;
        /** The nonce provided by /v1/user/oidc/authenticate. */
        nonce: string;
        /** The stage provided by /v1/user/oidc/authenticate. */
        stage: string;
        /** The value of a cookie used for session stickiness between this service & AM */
        amlb: string;
      };
    };
    responses: {
      /** The OTP was correctly provided */
      200: {
        schema: definitions['AuthenticationResponse'];
      };
      /** Bad Request */
      400: {
        schema: definitions['Response'];
      };
      /** The OTP was incorrect, the nonce is expired, or too many attempts have been made to validate this nonce. */
      401: {
        schema: definitions['Response'];
      };
      /** I don't know when this will be returned */
      403: {
        schema: definitions['Response'];
      };
      /** Internal Server Error */
      500: {
        schema: definitions['Response'];
      };
    };
  };
  resendFactor: {
    parameters: {
      header: {
        /** Identifies the user realm, failure to provide a value would result in defaulting to SPARK_ID realm. */
        Realm?: parameters['Realm'];
      };
      query: {
        /** The nonce provided by /v1/user/oidc/authenticate. */
        nonce: string;
        /** The stage provided by /v1/user/oidc/authenticate. */
        stage: string;
        /** The value of a cookie used for session stickiness between this service & AM */
        amlb: string;
      };
    };
    responses: {
      200: {
        schema: definitions['MfaRenewResponse'];
      };
      /** Bad Request */
      400: {
        schema: definitions['Response'];
      };
      /** I don't know when this will be returned */
      401: {
        schema: definitions['Response'];
      };
      /** I don't know when this will be returned */
      403: {
        schema: definitions['Response'];
      };
      /** Internal Server Error */
      500: {
        schema: definitions['Response'];
      };
    };
  };
}
